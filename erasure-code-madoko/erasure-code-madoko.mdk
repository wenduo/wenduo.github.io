Title         : 纠删码
Author        : 360基础架构组王文铎
Logo          : True

[TITLE]

# 本文缘起

近期发现很多人都对纠删码很感兴趣，正好我做过纠删码相关的调研，因此写了这篇文章。

本文的部分图片参考了James.Plank教授[一篇很好的综述ppt][ppt] 

# 纠删码的背景

## 什么是纠删码？为什么叫纠删码？
纠删码起源于通信领域。通信中，我们需要把一大块数据切成很多数据帧来逐次传输。这些帧在传输的过程中可能会出现错误或者干脆整帧被丢掉。
为了解决这一问题，通信中将k个原始数据帧编码成n(n>k)个新数据帧进行传输。+

[ppt]:http://web.eecs.utk.edu/~plank/plank/papers/FAST-2013-Tutorial.html

## 什么叫mds纠删码


# RS纠删码示例

# LRC纠删
## 为什么还要有LRC纠删码？
衡量分布式系统有两个重要指标，可用性和可靠性。可用性指系统平均可以正常工作的时间。而可靠性是指系统在t时间内正常工作的概率。
所以谈可靠性一定要有时间。比如一个系统每1秒内都有1ms不能正常工作，那么他的可用性是99.9%。而一小时内不出故障的可靠性是0。
当纠删码对应的数据块发生故障之后，我们需要读冗余及其他数据块，计算出坏掉的数据块内的数据并恢复后才能系统回到可用状态。
因此，可用性很大程度上取决于修复所用的时间。绝大部分的故障，其实只有一个硬盘坏掉，在这种情况下，RS编码为了修复这个坏掉的数据块需要读取全部剩余的数据块及至少一个冗余块。这个过程受到cpu和网卡的限制会很慢。
意味着可用性的降低。而LRC编码正是为了解决这个问题。
## LRC纠删是如何做的？
LRC全名是local seperabal code。LRC除了global的冗余块之外，还将数据块分组，给每组数据块增加冗余。这样当一个数据块故障，只需要读取组内的数据块及冗余块，大大提高恢复速度。
下面是RS(12，3) 和 LRC(12,2,1)的对比。

~ Figure {caption:"RS(12,3)"}
![lrc1]

[lrc1]: images/lrc1.PNG "lrc1" { width:auto; max-width:80% }
~
~ Figure {caption:"LRC(12,2,1)"}
![lrc2]

[lrc2]: images/lrc2.PNG "lrc2" { width:auto; max-width:80% }
~
当一个数据块出现故障，RS(12,3)需要读11个data块加1个冗余块，而LRC(12,2,1)只需要读5个数据块加1个冗余块。

# 应用场景

