Title         : 存储系统中的纠删码
Author        : 360基础架构组王文铎

[TITLE]

# 本文缘起

近期发现很多人都对纠删码很感兴趣，正好我做过纠删码相关的调研工作，因此写了这篇文章。

本文的部分图片参考了James.Plank教授[一篇很好的综述ppt][ppt].

[ppt]:http://web.eecs.utk.edu/~plank/plank/papers/FAST-2013-Tutorial.html

# 纠删码的背景

## 什么是纠删码？为什么叫纠删码？

纠删码起源于通信领域。通信中，我们需要把一大块数据切成很多数据帧来逐次传输。这些帧在传输的过程中可能会出现错误或者干脆整帧被丢掉。
为了解决这一问题，可以将k个原始数据帧编码成n(n>k)个带冗余的新数据帧再进行传输。目的节点接收到足够多的数据帧后，解码得到原始的k个数据帧。

"编码后某些帧出错了也能解码出原始数据帧"的编码叫做纠错码。
"编码后某些帧丢掉了也能解码出原始数据帧"的编码叫做纠删码。两者的不同在于，纠错码不知道是否发生了错误及错误的位置，而纠删码明确的知道我们丢失了哪些数据帧。
虽然纠错码更厉害一些，但比如网络的延时/丢包，硬盘损毁等问题，其实是纠删的问题，通过纠删码就可以得到解决。


## 他们常说mds编码，感觉很厉害，什么叫mds纠删码？
mds码全名是maxinum distance code. mds码是“编码后的n个数据帧只要还剩余下k个，就能够恢复出原始的k个数据帧”的编码。

具体的解释：假设我们把k位的二进制数据编码成n位的二进制数据。这个编码C实际上把所有k位二进制数组成的集合$\Omega_k$映射到了所有n位二进制数组成的空间$\Omega_n$.
为了能够解码,这个编码需要是一个单射.意味着映射之后,$\Omega_n$空间中有对应的$2^k$个数据点，设为点集A。

不妨设A中点a1，a2的汉明距离为A中最小，设为d。即a1,a2有d位是不同的，且A中其他点间至少有d位不同。又不妨设a1，a2来自于$\Omega_k$中的两个点k1，k2。
删除掉a1.a2这d位之后，显然我们没办法去区分a1和a2，也就没办法去区分k1及k2了.

所以如果设编码的纠删能力为$\theta$，即编码后任意$\theta$位数据丢失,仍能解码出原始的k位数据,有:
~ Equation { #euler3; caption:"Euler's formula" }
\theta <= d - 1
~

同时根据d的定义，A中任意两元素间都至少有d位不同。考虑从$\Omega_n$空间到$\Omega_{n-(d-1)}$空间的一个映射f，f将A中元素的前d-1位删掉。那么A中的元素经过f映射后至少还有1位不同。即f也是一个单射。
又因为编码C也是单射，所以存在一个$\Omega_k$到 $\Omega_{n-(d-1)}$的单射。由单射性质，有

~ Equation { #euler3; caption:"Euler's formula" }
\lvert \Omega_k \rvert <= \lvert \Omega_{n-(d-1)} \rvert
~
即 
~ Equation { #euler4; caption:"Euler's formula" }
2^k <= 2^{n-d+1}
~
结合(1),可以得到
~ Equation { #euler5; caption:"Euler's formula" }
\theta <= n - k 
~
![lrc2]
![lrc1]
我们刚才其实直观的解释了这个道理：将k位数据帧编码成n位数据帧(n-k位冗余)，纠错能力理论上最高只有n-k。mds码是达到理论上最高纠错能力的码。
这个结论和进制无关，对数据帧也使用。
# RS纠删码示例

[lrc2]: images/lrc2.PNG "lrc2" { width:auto; max-width:90% }

[lrc1]: images/lrc1.PNG "lrc1" { width:auto; max-width:90% }

# LRC纠删

## 为什么还要有LRC纠删码？
衡量分布式系统有两个重要指标，可用性和可靠性。可用性指系统平均可以正常工作的时间。而可靠性是指系统在t时间内正常工作的概率。
所以谈可靠性一定要有时间。比如一个系统每1秒内都有1ms不能正常工作，那么他的可用性是99.9%。而一小时内不出故障的可靠性是0。
当纠删码对应的数据块发生故障之后，我们需要读冗余及其他数据块，计算出坏掉的数据块内的数据并恢复后才能系统回到可用状态。
因此，可用性很大程度上取决于修复所用的时间。绝大部分的故障，其实只有一个硬盘坏掉，在这种情况下，RS编码为了修复这个坏掉的数据块需要读取全部剩余的数据块及至少一个冗余块。这个过程受到cpu和网卡的限制会很慢。
意味着可用性的降低。而LRC编码正是为了解决这个问题。

## LRC纠删是如何做的？
LRC全名是local seperabal code。LRC除了global的冗余块之外，还将数据块分组，给每组数据块增加冗余。这样当一个数据块故障，只需要读取组内的数据块及冗余块，大大提高恢复速度。
下面是RS(12，3) 和 LRC(12,2,1)的对比。

~ Figure { caption:"RS(12,3)" }
![lrc1]
~

~ Figure { caption:"LRC(12,2,1)" }
![lrc2]
~

[lrc1]: images/lrc1.PNG "lrc1" { width:auto; max-width:80% }
[lrc2]: images/lrc2.PNG "lrc2" { width:auto; max-width:80% }
由上图可以看到，当一个数据块出现故障，RS(12,3)需要读11个data块加1个冗余块，而LRC(12,2,1)只需要读5个数据块加1个冗余块就可以计算并恢复出故障数据块。
同样能纠删能力下，LRC编码系统的可用性要高很多。

# 纠删码的实际应用场景

## 那么何时应该使用纠删码呢？
根据上面的分析，我们可以看到，如果你的系统使用纠删码而不是主从结构的三副本，这意味着

* 每次写入都要进行矩阵运算得到冗余，
* Bread.
  A nested list:
  - white
  - whole grain
* Basil.
